# JavaScript Coding Practice Problems ðŸš€

This repository contains a collection of JavaScript coding problems ranging from basic to advanced topics. Each problem is categorized by topic to help you practice and improve your JavaScript skills.

## Table of Contents

1. [Basic JavaScript](#basic-javascript)
2. [Arrays](#arrays)
3. [Strings](#strings)
4. [Objects](#objects)
5. [Functions](#functions)
6. [ES6](#es6)
7. [Algorithms](#algorithms)
8. [Data Structures](#data-structures)

---

## Basic JavaScript

1. **Hello World**  
   Print "Hello, World!" to the console.

2. **Variables and Constants**  
   Declare variables of different types (string, number, boolean).  
   Declare and initialize constants.

3. **Operators**  
   Perform basic arithmetic operations (addition, subtraction, multiplication, division).  
   Use comparison operators (>, <, ===, !==).

4. **Control Structures**  
   Implement conditional statements (if-else, switch-case).  
   Use loops (for, while) to iterate over arrays and objects.

5. **Functions**  
   Define a function that takes parameters and returns a value.  
   Write functions with default parameters and rest parameters.

6. **Arrays**  
   Create arrays and perform operations like push, pop, shift, unshift.  
   Iterate through arrays using for loops and forEach.

7. **Strings**  
   Concatenate two strings.  
   Find the length of a string.  
   Convert a string to uppercase or lowercase.

8. **Objects**  
   Create objects with properties and methods.  
   Access object properties using dot notation and bracket notation.

9. **Scope and Hoisting**  
   Understand variable scope inside and outside functions.  
   Recognize and explain function and variable hoisting.

10. **Type Conversion**  
    Convert between different data types (string to number, number to string).

11. **Error Handling**  
    Use try-catch blocks to handle exceptions.  
    Throw custom errors with throw statements.

12. **DOM Manipulation**  
    Select and manipulate DOM elements using vanilla JavaScript.  
    Handle events (click, mouseover, keypress) on DOM elements.

13. **Asynchronous JavaScript**  
    Use callbacks to handle asynchronous operations.  
    Fetch data from an API using fetch() and handle responses.

14. **LocalStorage**  
    Store and retrieve data from the browser's localStorage.  
    Use localStorage to persist user settings or data.

15. **Regular Expressions**  
    Create regular expressions to match patterns in strings.  
    Use RegExp methods like test() and exec().

16. **Math Operations**  
    Perform mathematical operations (exponents, square roots).
    
17. **Date and Time**  
    Manipulate dates (formatting, adding days, calculating differences).

18. **Functional Programming**  
    Use higher-order functions (map, filter, reduce) to process data.
    
19. **ES5 vs ES6 Syntax**  
    Convert ES5 code to ES6 syntax and vice versa.
    
20. **Bitwise Operations**  
    Perform bitwise operations (AND, OR, XOR, shift).

---

## Arrays

1. **Array Operations**  
   Create an array and perform operations like push, pop, shift, unshift, etc.
   
2. **Array Iteration**  
   Write a function to iterate through an array and perform an operation on each element.

3. **Array Methods**  
   Use array methods such as map(), filter(), reduce(), and forEach().
   
4. **Sorting**  
   Implement sorting algorithms for arrays (bubble sort, merge sort, quick sort).

5. **Searching**  
   Implement searching algorithms for arrays (binary search, linear search).

6. **Multi-dimensional Arrays**  
   Manipulate and traverse multi-dimensional arrays.

7. **Array Slice and Splice**  
   Use slice() and splice() to manipulate arrays.

8. **Flatten an Array**  
   Flatten nested arrays into a single array.

9. **Array Comparison**  
   Compare two arrays and find common elements.

10. **Rotate an Array**  
    Rotate elements of an array to the left or right.

11. **Shuffle an Array**  
    Shuffle elements randomly in an array.

12. **Find Maximum and Minimum**  
    Find the maximum and minimum values in an array.

13. **Remove Duplicates**  
    Remove duplicate elements from an array.

14. **Array Concatenation**  
    Concatenate multiple arrays into one.

15. **Sparse Arrays**  
    Handle sparse arrays and their implications.

16. **Palindrome Array**  
    Check if an array is a palindrome.

17. **Chunk an Array**  
    Split an array into chunks of a specified size.

18. **Intersecting Arrays**  
    Find common elements between two arrays.

19. **Array Reverse**  
    Reverse the elements of an array in place.

20. **Insert Element at Index**  
    Insert an element at a specific index in an array.

---

## Strings

1. **String Manipulation**  
   Concatenate two strings.  
   Find the length of a string.  
   Convert a string to uppercase or lowercase.

2. **Substring Operations**  
   Extract a substring from a string.  
   Replace substrings within a string.

3. **Regular Expressions**  
   Use regular expressions to match patterns in strings.  
   Validate email addresses or other input formats using regex.

4. **String Comparison**  
   Compare two strings for equality.

5. **String Palindrome**  
   Check if a string is a palindrome.

6. **String Reverse**  
   Reverse the characters of a string.

7. **Count Characters**  
   Count occurrences of each character in a string.

8. **Capitalize Words**  
   Capitalize the first letter of each word in a string.

9. **Trimming Whitespace**  
   Remove leading and trailing whitespace from a string.

10. **String Compression**  
    Compress a string by replacing consecutive characters with their counts.

11. **Anagrams**  
    Check if two strings are anagrams of each other.

12. **String Rotation**  
    Check if one string is a rotation of another string.

13. **Unicode Operations**  
    Handle Unicode characters in strings.

14. **Substring Search**  
    Implement substring search in a string.

15. **String Conversion**  
    Convert between different string formats (camelCase, snake_case, kebab-case).

16. **String Split and Join**  
    Split a string into an array of substrings and join them back.

17. **String Interpolation**  
    Use string interpolation to construct dynamic strings.

18. **String Permutations**  
    Generate all permutations of a string.

19. **Substring Frequency**  
    Count occurrences of a substring in a string.

20. **String Padding**  
    Pad a string to a specified length with another string.

---

## Objects

1. **Object Creation**  
   Create an object with properties and methods.  
   Define and access object properties.

2. **Object Manipulation**  
   Modify object properties.  
   Iterate through object properties using loops or Object.keys().

3. **Object Oriented Programming**  
   Implement inheritance and polymorphism using prototypes or classes.  
   Create constructor functions and instantiate objects.

4. **Object Comparison**  
   Compare two objects for equality.

5. **Object Serialization**  
   Serialize an object into JSON and deserialize JSON back into an object.

6. **Object Cloning**  
   Create a deep clone of an object.

7. **Object Composition**  
   Combine multiple objects into a single object.

8. **Object Iteration**  
   Iterate over object properties using for...in loops.

9. **Object Freeze and Seal**  
   Use Object.freeze() and Object.seal() to control object mutability.

10. **Nested Objects**  
    Work with deeply nested objects and access nested properties.

11. **Object Property Deletion**  
    Delete properties from an object.

12. **Object Conversion**  
    Convert objects to primitive values using toString() and valueOf().

13. **Object Destructuring**  
    Use object destructuring to extract values into variables.

14. **Immutable Objects**  
    Implement immutability in objects.

15. **Object Merge**  
    Merge properties of two objects into a new object.

16. **Object Validation**  
    Validate object properties against a schema or rules.

17. **Object Polymorphism**  
    Implement polymorphic behavior using objects.

18. **Object Map**  
    Map values of an object to another format.

19. **Object Deep Comparison**  
    Compare nested objects deeply for equality.

20. **Object Properties**  
    Access and manipulate object properties dynamically.

---

## Functions

1. **Function Basics**  
   Define a function that takes parameters and returns a value.  
   Write functions with default parameters and rest parameters.

2. **Function Scope**  
   Understand variable scope inside and outside functions.  
   Recognize and explain function and variable hoisting.

3. **Higher Order Functions**  
   Use higher-order functions like map(), filter(), reduce() to manipulate arrays.  
   Implement functions that return other functions (closures).

4. **Recursion**  
   Write recursive functions to solve problems like factorial calculation or Fibonacci sequence generation.
   
5. **Callback Functions**  
   Use callback functions to handle asynchronous operations.

6. **Function Composition**  
   Compose functions together to create new functions.

7. **Currying**  
   Implement currying in functions.

8. **Memoization**  
   Cache function results for performance optimization.

9. **Function Bind**  
   Use Function.prototype.bind() to bind context to a function.

10. **Function Return Types**  
    Define and enforce return types for functions.

11. **Function Overloading**  
    Simulate function overloading in JavaScript.

12. **Partial Application**  
    Implement partial application of functions.

13. **Anonymous Functions**  
    Use anonymous functions for one-time use.

14. **IIFE (Immediately Invoked Function Expression)**  
    Use IIFE to create local scopes and avoid polluting the global namespace.

15. **Async Functions**  
    Define and use async functions with async/await.

16. **Generator Functions**  
    Use generator functions to control iterative flows.

17. **Function Timing**  
    Measure execution time of functions.

18. **Error Handling in Functions**  
    Handle errors gracefully within functions.

19. **Function Parameters Validation**  
    Validate function parameters before execution.

20. **Function Memoization**  
    Implement memoization to optimize recursive functions.

---

## ES6

1. **Arrow Functions**  
   Convert traditional functions to arrow functions.  
   Use arrow functions with implicit and explicit return.

2. **Template Literals**  
   Use template literals for string interpolation.  
   Multiline strings with template literals.

3. **Let and Const**  
   Understand block scoping with let and const.  
   Use const for constants that should not be reassigned.

4. **Destructuring**  
   Destructure arrays and objects to extract values into variables.  
   Use destructuring in function parameters and for variable assignment.

5. **Modules**  
   Import and export modules using ES6 syntax (import/export).  
   Create and use modules to organize code into reusable components.

6. **Classes**  
   Define classes and create instances using constructor and methods.  
   Implement inheritance using extends and super keywords.

7. **Promises**  
   Use Promises for asynchronous operations.  
   Chain promises using then() and handle errors with catch().

8. **Async/Await**  
   Simplify asynchronous code using async functions and await keyword.

9. **Rest and Spread Operators**  
   Use rest parameters and spread operator for function arguments and array/object manipulation.

10. **Set and Map**  
    Use Set and Map data structures for unique collections and key-value mappings.

11. **Symbols**  
    Define and use symbols as unique object keys.

12. **Generators**  
    Use generators to control iterative flows.

13. **Proxy Objects**  
    Create and use Proxy objects for meta-programming.

14. **Default Parameters**  
    Define default values for function parameters.

15. **Computed Property Names**  
    Use computed property names in objects.

16. **Array Destructuring**  
    Destructure arrays into individual variables.

17. **Object Destructuring**  
    Destructure objects into individual variables.

18. **Promise.all and Promise.race**  
    Use Promise.all() and Promise.race() for handling multiple promises.

19. **Optional Chaining**  
    Safely access nested properties with optional chaining (?. operator).

20. **Nullish Coalescing Operator**  
    Use nullish coalescing operator (??) to provide default values for null or undefined.

---

## Algorithms

1. **Sorting Algorithms**  
   Implement various sorting algorithms (bubble sort, merge sort, quick sort).
   
2. **Searching Algorithms**  
   Implement searching algorithms (binary search, linear search).
   
3. **Graph Algorithms**  
   Implement graph traversal algorithms (DFS, BFS).  
   Solve problems involving shortest path algorithms (Dijkstra's algorithm).

4. **Dynamic Programming**  
   Solve problems using dynamic programming techniques (fibonacci sequence, knapsack problem).

5. **Backtracking**  
   Implement backtracking algorithms (N-Queens problem, Sudoku solver).

6. **Greedy Algorithms**  
   Solve problems using greedy algorithms.

7. **Divide and Conquer**  
   Apply divide and conquer strategy to solve problems.

8. **String Algorithms**  
   Solve problems related to strings (substring search, palindrome detection).

9. **Array Algorithms**  
   Solve problems related to arrays (subset generation, permutation).

10. **Mathematical Algorithms**  
    Implement mathematical algorithms (factorial calculation, prime number generation).

11. **Tree Algorithms**  
    Traverse trees and solve problems related to binary trees.

12. **Sorting Challenges**  
    Solve specific challenges related to sorting.

13. **Graph Challenges**  
    Solve specific challenges related to graph algorithms.

14. **Dynamic Programming Challenges**  
    Solve specific challenges using dynamic programming.

15. **Geometry Algorithms**  
    Implement algorithms related to computational geometry.

16. **Number Theory Algorithms**  
    Solve problems related to number theory (GCD, LCM).

17. **Bit Manipulation**  
    Solve problems using bit manipulation techniques.

18. **Combinatorial Algorithms**  
    Solve problems involving combinations and permutations.

19. **Parallel Algorithms**  
    Implement algorithms suitable for parallel execution.

20. **Optimization Problems**  
    Solve optimization problems using algorithms.

---

## Data Structures

1. **Arrays**  
   Implement basic array operations (insert, delete, update).  
   Use arrays to implement stack and queue data structures.

2. **Linked Lists**  
   Implement singly linked lists.  
   Use linked lists to solve problems like reversing a list or detecting cycles.

3. **Stacks**  
   Implement stack operations (push, pop, peek).  
   Use stacks to solve problems like balanced parentheses or postfix evaluation.

4. **Queues**  
   Implement queue operations (enqueue, dequeue).  
   Use queues to solve problems like implementing a circular queue or a priority queue.

5. **Trees**  
   Implement binary trees and binary search trees (BST).  
   Traverse trees using depth-first search (DFS) and breadth-first search (BFS).

6. **Heaps**  
   Implement heap operations (insert, delete, heapify).  
   Use heaps to solve problems like implementing a priority queue.

7. **Hash Tables**  
   Implement hash table operations (insert, delete, lookup).  
   Solve problems involving collisions and hash function design.

8. **Graphs**  
   Implement graph representations (adjacency matrix, adjacency list).  
   Use graphs to solve problems like finding connected components or shortest paths.

9. **Tries**  
   Implement tries (prefix trees) and solve problems like autocomplete.

10. **Disjoint Sets (Union-Find)**  
    Implement disjoint-set data structure and solve related problems.

11. **Segment Trees**  
    Implement segment trees and solve range query problems.

12. **Fenwick Trees (Binary Indexed Trees)**  
    Implement Fenwick trees for efficient prefix sum calculations.

13. **Splay Trees**  
    Implement splay trees and perform self-adjusting binary search.

14. **Suffix Trees and Arrays**  
    Implement suffix trees and suffix arrays for pattern matching.

15. **Red-Black Trees**  
    Implement red-black trees and maintain balance during insertion and deletion.

16. **B-Trees**  
    Implement B-trees for disk-based data structures.

17. **Priority Queues**  
    Implement priority queues using heaps or other suitable data structures.

18. **Sparse Matrices**  
    Implement sparse matrices and perform operations efficiently.

19. **Persistent Data Structures**  
    Implement persistent versions of basic data structures.

20. **Concurrency Structures**  
    Implement data structures suitable for concurrent programming.

---

Feel free to fork this repository and add more problems or improve existing solutions. Happy coding! ðŸŒŸ
